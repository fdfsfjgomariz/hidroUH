# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ModelUH
                                 A QGIS plugin
 PACOGOM METE DESCRIPCION
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-05-21
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Water and Environment Institute (INUAMA). University of Murcia
        email                : fjgomariz@um.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Model_UH_dialog import ModelUHDialog
import os.path

#PACOGOM
from qgis.core import *
import random

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

#PACOGOM para la tabla
from PyQt5.QtWidgets import QTableWidgetItem


#PACOGOM
#import ':/plugins/q_scs/funcionesHidro.py'


class ModelUH:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ModelUH_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            #PACOGOM usado para translators. Si lo uso mira las siguientes lineas del otro
            #QCoreApplication.installTranslator(self.translator)
        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Model UH')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        #PACOGOM este no lo incluye y en cambio si: self.toolbar = self.iface.addToolBar(u'Tc Tlag')
        self.first_start = None
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ModelUH', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Model_UH/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Model UH for events'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
        
        
        #PACOGOM para ver ayuda en qgis en ayuda:
        self.help_action = QAction(
            QIcon("testplug:icon.png"),
            self.tr("Test Plugin Model UH"),
            self.iface.mainWindow()
        )
        #PACOGOM
        # Add the action to the Help menu
        self.iface.pluginHelpMenu().addAction(self.help_action)
        self.help_action.triggered.connect(self.show_help)

    #PACOGOM y para finalizar lo anterior Y CAMBIAR POR LA WEB QUE PROCEDA
    @staticmethod
    def show_help():
        """ Open the online help. """
        QDesktopServices.openUrl(QUrl('https://www.um.es'))

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Model UH'),
                action)
            self.iface.removeToolBarIcon(action)
            
        # PACOGOM remove the toolbar incluir si incluyo el de la linea 36
        #del self.toolbar 
        
        
    #PACOGOM OK aqui va lo de la seleccion de los layers en este def
    def select_layer_fields(self, vlayer):
    
        self.dlg.cb_ID.setLayer(vlayer)
        self.dlg.cb_cn.setLayer(vlayer)
        self.dlg.cb_area.setLayer(vlayer)
        self.dlg.cb_lp.setLayer(vlayer)
        self.dlg.cb_max_height.setLayer(vlayer)
        self.dlg.cb_min_height.setLayer(vlayer)
        
        self.dlg.cb_lc.setLayer(vlayer)
        self.dlg.cb_minl.setLayer(vlayer)
        self.dlg.cb_maxl.setLayer(vlayer)

        field = self.dlg.cb_lp.setLayer(vlayer)
        
    #PACOGOM OK aqui va lo de la seleccion de los layers en este def complementario al anterior. No obstante creo que no es necesario porque veo que es para los check
    def check_box_able(self):

        colID = self.dlg.cb_ID.currentField()    
        colCN = self.dlg.cb_cn.currentField()
        
        if colCN == "":
            self.dlg.rb_dry.setEnabled(False)
            self.dlg.rb_normal.setEnabled(False)
            self.dlg.rb_wet.setEnabled(False)
        else:
            self.dlg.rb_dry.setEnabled(True)
            self.dlg.rb_normal.setEnabled(True)
            self.dlg.rb_wet.setEnabled(True)
        
        if self.dlg.ch_routing.isChecked():
            self.dlg.cb_lc.setEnabled(True)
            self.dlg.cb_minl.setEnabled(True)
            self.dlg.cb_maxl.setEnabled(True)
        else:
            self.dlg.cb_lc.setEnabled(False)
            self.dlg.cb_minl.setEnabled(False)
            self.dlg.cb_maxl.setEnabled(False)            
 
    #PACOGOM
    def sql_funtion(self):
        vlayer = self.dlg.cb_invector.currentLayer()
        field = self.dlg.cb_lp.currentText()
        
        
    #PACOGOM para la tabla
    def llenar_tabla(self, dataframe):
        #referencia al objeto
        tabla = self.dlg.table_results
        #encabezados y filas:
        encabezados = dataframe.columns.tolist()
        datos = dataframe.values.tolist()
        #configurar columnas
        tabla.setColumnCount(len(encabezados))
        tabla.setRowCount(len(datos))
        tabla.setHorizontalHeaderLabels(encabezados)
        #filas

        #y llenamos la tabla
        for fila_idx, fila in enumerate(datos):
            for columna_idx, valor in enumerate(fila):
                item = QTableWidgetItem(str(valor))
                tabla.setItem(fila_idx, columna_idx, item)

        tabla.resizeColumnsToContents()
        tabla.horizontalHeader().setStretchLastSection(True)
        tabla.setStyleSheet("QHeaderView::section { background-color: #4CAF50; color: white; }")

        #tabla.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        #tabla.setStyleSheet("QHeaderView::section{ background-color: lightblue }")
        
    #PACOGOM CREAR GRAFICO HIDROGRAMA###################
    #recuerda que primero he cargado QWebEngineView
    
    def generar_grafico(self,tabla):
        # Datos desde el DataFrame
        data_json = tabla.to_json(orient='records', date_format='iso')

        # HTML con el gráfico
        html_content = f"""
        <html>
        <head><script src="https://cdn.plot.ly/plotly-latest.min.js"></script></head>
        <body>
            <div id="chart" style="width:100%; height:100%;"></div>
            <script>
                var data = {data_json};
                var trace1 = {{
                    x: data.map(d => d.time),
                    y: data.map(d => d.QObs),
                    type: 'scatter',
                    name: 'QObs'
                }};
                var trace2 = {{
                    x: data.map(d => d.time),
                    y: data.map(d => d.QSim),
                    type: 'scatter',
                    name: 'QSim'
                }};
                Plotly.newPlot('chart', [trace1, trace2], {{title: 'Caudales'}});
            </script>
        </body>
        </html>
        """
        self.dlg.View_hidro.setHtml(html_content)    
        
    
 
    #PACOGOM: ummm pra importar paquetes etc. Lo necsito. Y además el codigo para ejecutar etc que es el process
    def process(self,vlayer):

        try:
            import pip
        except:
            execfile(os.path.join(self.plugin_dir, get_pip.py))
            import pip
            # just in case the included version is old
            pip.main(['install','--upgrade','pip'])

        try:
            import math
        except:
            pip.main(['install', 'math'])

        try:
            import numpy
        except:
            pip.main(['install', 'numpy'])
            
        #PACOGOM y mias:
        try:
            import tempfile
        except:
            pip.main(['install', 'tempfile'])
        try:
            import pandas
        except:
            pip.main(['install', 'pandas'])

        try:
            import sys
        except:
            pip.main(['install', 'sys'])  
            
        try:
            import os
        except:
            pip.main(['install', 'os'])    
        try:
            import matplotlib.pyplot
        except:
            pip.main(['install', 'matplotlib.pyplot'])   

        try:
#            from scipy.optimize import minimize
            import scipy.optimize
        except:
            pip.main(['install','--upgrade' ,'scipy.optimize']) 
       

        #Functions
        def funncMod(p=[1,2,3,4,5], nc=58):
            S = 25400/nc - 254
            Ia = 0.2*S
            PeTot = ((np.sum(p) - 0.2*S)**2)/(np.sum(p) + 0.8*S)
            Fa = np.sum(p)- (Ia+PeTot) 
            #print(Ia, PeTot, Fa )
            P_ac = np.cumsum(p)
            Ia_ac, Pe_ac, F_ac = [np.nan]*len(p),  [np.nan]*len(p), [np.nan]*len(p)
            for t in range(len(p)):
                Ia_ac[t] = P_ac[t] if P_ac[t]<Ia  else Ia   
                Pe_ac[t]=( (P_ac[t]-Ia_ac[t])**2) / (P_ac[t] + S -Ia_ac[t])
                F_ac[t]=P_ac[t]-(Pe_ac[t]+Ia_ac[t])
                #print(P_ac)
            #print(Ia_ac)
            #print(F_ac)
            #print(Pe_ac)
            Pe = [Pe_ac[0]];Pe.extend(np.diff(Pe_ac))
            F = [F_ac[0]]; F.extend(np.diff(F_ac))
            Ia = [Ia_ac[0]]; Ia.extend(np.diff(Ia_ac))

            return(pd.DataFrame({"P":p, "Ia":Ia, "F":F, "Pe":Pe}))

        def funHUmod(area:float,tc:float, duracion:int, dt:int=30, prop:bool=False):
            tp = duracion/2 + 0.35*tc                         # horas
            qp = 0.208 * area /tp                             # m3/s 
            tb = 2.67* tp                                     # horas
            q = []
            pasos = round(tb*60)
            for i in range(pasos):                            # Cálculo minuto a minuto 
                t=(i-1)/60                                    # Tiempo en horas
                if t<=tp: q.append(t*qp/tp)                   # Cálculo q en la rama ascendente del HU
                if t>tp:  q.append(qp - (t-tp)*qp/(tb-tp))    # Cálculo q en la rama descendente del HU
            q = [qq*60 for qq in q]                           # Paso del caudal de m3/seg a m3/min
            qcum = []
            for i in range(0,len(q),dt): 
                qcum.append(sum(q[i:i+dt]))
            if prop is False:
                return(qcum)
            else: 
                qprop = [q/sum(qcum) for q in qcum]                             
            return(qprop)

        def funHUconv(p, hu, area, intervalo):
            area = area * 1000000         # paso el área a m2
            intervalo = intervalo * 3600  # paso el intervalo a segundos
            h = [0] * (len(p)+len(hu)-1)
            for t in range(len(hu)): 
                conv = hu[t] * p
                h[t:(t+len(p))] = h[t:(t+len(p))] + conv
   
            return([hh*area/(1000*intervalo) for hh in h]) #paso de l/m2 a m3/m2
        
        def funnse(predictions, targets):
            return 1 - (np.sum((targets - predictions) ** 2) / np.sum((targets - np.mean(targets)) ** 2))
    
        def funrmse(predictions, targets):
            return np.sqrt(((predictions - targets) ** 2).mean())
    
        def funpbias(predictions, targets):
            return (np.sum(targets - predictions) / np.sum(predictions)) * 100
            
            
        #funcion objetivo
        def objectiveRMSE(params, p, qobs, area, duracion):
            #K, x = params
            CN, tc = params
            
            PERDIDAS = funncMod(p=p, nc=CN)
            Pe = np.array(PERDIDAS["Pe"])
            
            ##primero el HU
            hu = funHUmod(area=area, tc=tc, duracion=duracion)
            huProp = [h/sum(hu) for h in hu]
            huConv = funHUconv(Pe, huProp, area, duracion)
            
            if(len(huConv) > len(Pe)):
                huConv = huConv[0:len(Pe)]

            f0 = funrmse(np.array(huConv),np.array(qobs))
            return f0

        def objectiveNSE(params, p, qobs, area, duracion):
            #K, x = params
            CN, tc = params
            
            PERDIDAS = funncMod(p=p, nc=CN)
            Pe = np.array(PERDIDAS["Pe"])
            
            ##primero el HU
            hu = funHUmod(area=area, tc=tc, duracion=duracion)
            huProp = [h/sum(hu) for h in hu]
            huConv = funHUconv(Pe, huProp, area, duracion)
            
            if(len(huConv) > len(Pe)):
                huConv = huConv[0:len(Pe)]

            f0 = funnse(np.array(huConv),np.array(qobs))
            return - f0

        #PACOGOM ea prueba a ver        
        #print(self.dlg.output.filePath())

        if self.dlg.output.filePath() != '' and self.dlg.cb_invector.currentLayer():
        
            import os
            #PACOGOM OK ESTO ES PARA EL ARCHIVO QUE SE EXPORTA
            if os.path.exists(self.dlg.output.filePath()):
                
                shape = self.dlg.cb_invector.currentLayer()
                ruta = self.dlg.output.filePath()
                options = QgsVectorFileWriter.SaveVectorOptions()
                options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteFile
                options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
                options.actionOnExistingFile = QgsVectorFileWriter.AppendToLayerNoNewFields
                options.shape = "_".join(shape.name().split(' '))
                writer = QgsVectorFileWriter.writeAsVectorFormat(shape,ruta,options)
                layer = QgsVectorLayer(ruta, os.path.basename(ruta), "ogr")
                provider = layer.dataProvider()
                
            else:
            
                shape = self.dlg.cb_invector.currentLayer()
                ruta = self.dlg.output.filePath()
                writer = QgsVectorFileWriter.writeAsVectorFormat(shape,ruta,"UTF-8",shape.crs(),driverName="ESRI Shapefile")
                layer = QgsVectorLayer(ruta, os.path.basename(ruta), "ogr")
                provider = layer.dataProvider()
                
            #print(ruta)
            #print(layer) 

            #Parameters index

            L = self.dlg.cb_lp.currentField()
            A= self.dlg.cb_area.currentField()

            narr = []
            q1 = []
            na =[]
            contador=0
            #PACOGOM Y DESPUES A PARTIR DE LA L830 METEN CONDICIONALES PARA AÑADIR LOS DATOS A LA NUEVA CAPA 
            
        #VOY A COLOCAR AQUI EL MODELO A VER:--------------
        #0 VARIABLES GENERICAS###############

        duracion = 1 # h
        #workdir = "G:/UNIVERSIDAD/ALONSOsolicitaTRANDIG21/plugin/RESULTADOS2/"
        
        if self.dlg.output2.filePath() != '':
            workdir = self.dlg.output2.filePath()
        #else:
        #QMessageBox.information(self,"Optimze stage",workdir)
       
        #1. CARGAR LOS DATOS#################

        #1.1. csv de precip y qobs (cambiar por seleccion de archivo):
        #archivoprec = workdir + "precip.csv"
        archivoprec = self.dlg.input_P.filePath()
        #colp = "P1"
        colp = 3
        codidp = 0
        
        #archivoprec = self.dlg.input_P.currentLayer()
        
        #archivoqobs = workdir + "hidrograma.csv"
        archivoqobs = self.dlg.input_Q.filePath()
        #colqobs = "qobs"
        colqobs = 3
  
        precip = pd.read_csv(archivoprec)
        iddate = precip.iloc[:,codidp]
        p = precip.iloc[:,colp].values

        if self.dlg.input_Q.filePath() != '':
            qobserved = pd.read_csv(archivoqobs)
            qobs = qobserved.iloc[:,colqobs].values
            iddate, qobs, p = zip(*sorted(zip(iddate, qobs, p)))
        else:
            iddate, p = zip(*sorted(zip(iddate, p)))

        #2. VARIABLES DE LA CUENCA Y LINEA FLUJO:###########

        #cambia por carga sele
        #archivocuenca = workdir + "basin.shp"
        #colCN = "cn"
        #colsup = "supkm"
        #colidbasin = "idbasin"
        #y el resto de columnas
        
        layer = self.dlg.cb_invector.currentLayer()
        colCN = self.dlg.cb_cn.currentField()
        colsup = self.dlg.cb_area.currentField()
        colidbasin = self.dlg.cb_ID.currentField()
        collen = self.dlg.cb_lp.currentField()
        colcmax = self.dlg.cb_max_height.currentField()
        colcmin = self.dlg.cb_min_height.currentField()        
    
        CN = []
        area = []
        idbasin = []
        lengthkm = []
        cmax = []
        cmin = []
        
        for feature in layer.getFeatures():
            CN = feature[colCN]
            area = feature[colsup]
            idbasin = feature[colidbasin]
            lengthkm = feature[collen]
            cmax = feature[colcmax]
            cmin = feature[colcmin]

        #3.  COMPONENTE PERDIDAS###############

        #ok tendre que cambiar en funcion de la longitud de registros

        PERDIDAS = funncMod(p=p, nc=CN)

        # Crear figura y ejes
        plt.figure(figsize=(10, 6))
        ax = PERDIDAS[["Ia","F","Pe"]].plot(kind='bar', stacked=True, color=['red', 'green', 'blue'])

        # Títulos y leyenda
        plt.title('Results of run model. CN loss method')
        plt.xlabel('Time')

        # Mostrar solo una etiqueta cada 5 posiciones
        ax.set_xticks(range(0, len(PERDIDAS), 5))
        ax.set_xticklabels(PERDIDAS.index[::5], rotation=45, ha='right')

        plt.ylabel('Precip. depth (mm)')
        #plt.grid(True, linestyle='--', alpha=0.6)

        # Calcular sumas totales
        sums = PERDIDAS[["P","Ia","F","Pe"]].sum()
        # Crear una tabla con las sumas
        plt.table(cellText=[sums.values.round(2)],
            colLabels=sums.index,
            cellLoc='center',
            loc='bottom',
            bbox=[0.18, -0.4, 0.6, 0.2])

        # Guardar imagen temporal
        #temp_dir = tempfile.gettempdir()
        temp_dir = workdir
        imagen_path = os.path.join(temp_dir, 'CNloss.png')

        plt.savefig(imagen_path, dpi=150, bbox_inches='tight')
        plt.close()

        # Mostrar en QGIS #SOLO FUNIONARA EN QGIS
        dialog = QDialog()
        dialog.setWindowTitle('Result CN loss method')
        layout = QVBoxLayout()
        label = QLabel()
        label.setPixmap(QPixmap(imagen_path))
        layout.addWidget(label)
        dialog.setLayout(layout)
        dialog.exec_()

        #4.  HIDROGRAMA###############

        desnivel = cmax - cmin
        pendiente = desnivel/(1000*lengthkm)
        tc = 0.06628 * lengthkm**0.77 / pendiente**0.385

        ##primero el HU
        hu = funHUmod(area=area, tc=tc, duracion=duracion)
        huProp = [h/sum(hu) for h in hu]
        Pe = np.array(PERDIDAS["Pe"])
        huConv = funHUconv(Pe, huProp, area, duracion)

        if(len(huConv) > len(Pe)):
            huConv = huConv[0:len(Pe)]

        #exportar tabla final:
        PERDIDAS2 = PERDIDAS.copy()
        PERDIDAS2['Qsim'] = huConv
        csv_path = os.path.join(temp_dir, 'model_results.csv')
        PERDIDAS2.to_csv(csv_path)

        #Y RESUMEN DE RESULTADOS:
        resultsres = {}
        resultsres['idbasin'] = idbasin
        resultsres.update(PERDIDAS.sum())
        resultsres['PeakSim'] = max(huConv)

        if self.dlg.input_Q.filePath() != '':
            resultsres['PeakObs'] = max(qobs)
            resultsres['nse'] = funnse(np.array(huConv),np.array(qobs))
            resultsres['rmse'] = funrmse(np.array(huConv),np.array(qobs))
            resultsres['pbias'] = funpbias(np.array(huConv),np.array(qobs))

        resultsres = pd.DataFrame([resultsres])
        resultsres_path = os.path.join(temp_dir, 'model_resum.csv')
        resultsres.to_csv(resultsres_path, index=False)
        
        #PACOGOM a ver si puedo sacar la tabla:
        self.llenar_tabla(resultsres.round(decimals=4))    

        #GRAFICO INCLUYENDO RESUUMEEN:

        # Crear figura y ejes
        plt.figure(figsize=(10, 6))
        plt.plot(iddate,huConv,color='blue',label='Simulated outflow',linestyle='-',)
        if self.dlg.input_Q.filePath() != '':
            plt.plot(iddate,qobs,color='black', label='Simulated outflow', linestyle='-',marker='o',markersize=3,alpha=0.7)
        #else:
        plt.title('Results for run')
        plt.xlabel('Time')
        plt.ylabel('Flow (m3/s)')
        plt.grid(True, linestyle='--', alpha=0.6)
        plt.legend()


        #carga en el QWidget:
        canvas = FigureCanvas(plt)
        layout = self.dlg.widgetHidro.layout()  # Asegúrate de tener un layout en Qt Designer
        if layout is None:
            layout = QVBoxLayout()
            self.dlg.widgetHidro.setLayout(layout)
        layout.addWidget(canvas)



        #temp_dir = tempfile.gettempdir()
        temp_dir = workdir
        imagen_path = os.path.join(temp_dir, 'QsimUH.png')
        plt.savefig(imagen_path, dpi=150, bbox_inches='tight')
        plt.close()

        # Mostrar en QGIS #SOLO FUNIONARA EN QGIS
        dialog = QDialog()
        dialog.setWindowTitle('Result UH flow')
        layout = QVBoxLayout()
        label = QLabel()
        label.setPixmap(QPixmap(imagen_path))
        layout.addWidget(label)
        dialog.setLayout(layout)
        dialog.exec_()
        
        #PACOGOM A VER SI PIRULA EL GRAFICO
        #generar_grafico(self,tabla)
        
        
        
        #6.  OPTIMIZACION###############
        
        if self.dlg.ch_optimize.isChecked():

            f0ej = "nse" #TIPO DE OPTIMIZAION    
            
            # Configuración de la optimización
            #initial_guess = [2.0, 0.2]  # Valores iniciales [K, x]
            #bounds = [
            #    (0.1, 100),   # Rango para K (K > 0)
            #    (0.0, 0.5)    # Rango para x (0 ≤ x ≤ 0.5)
            #]
            
            bounds = [(20, 99), (1,10)] #CN Y TLAG


            initial_guess = [50, 4]  # Valores iniciales

            if (f0ej == "rmse"):
                result = scipy.optimize.minimize(
                    fun=objectiveRMSE,
                    x0=initial_guess,
                    args=(p, qobs, area, duracion),
                    method='L-BFGS-B',  # Método que soporta límites
                    bounds=bounds,
                    options={'maxiter': 1, 'disp': True}
                )
            else:
                result = scipy.optimize.minimize(
                    fun=objectiveNSE,
                    x0=initial_guess,
                    args=(p, qobs, area, duracion),
                    method='L-BFGS-B',  # Método que soporta límites
                    bounds=bounds,
                    options={'maxiter': 1, 'disp': True}
                )        
            
            # Resultados
            if result.success:
            #    K_opt, x_opt = result.x
            #    print(f"Parámetros óptimos: K = {K_opt:.2f} h, x = {x_opt:.2f}")
            #    print(f"RMSE mínimo: {result.fun:.2f} m³/s")
                NC_opt = result.x
            else:
                print("Fail optimization:", result.message)
                
            #print(NC_opt)        
            

            ######EJECUTEMOS EL MODELO FINAL CON TODOS LOS PARAMETROS OPTIMIZADOS########

            #3.  COMPONENTE PERDIDAS###############

            #ok tendre que cambiar en funcion de la longitud de registros

            PERDIDASopt = funHidro.ncMod(p=p, nc=NC_opt[0,])

            # Crear figura y ejes
            plt.figure(figsize=(10, 6))
            ax = PERDIDASopt[["Ia","F","Pe"]].plot(kind='bar', stacked=True, color=['red', 'green', 'blue'])

            # Títulos y leyenda
            plt.title('Results of run optimized model. CN loss method')
            plt.xlabel('Time')

            # Mostrar solo una etiqueta cada 5 posiciones
            ax.set_xticks(range(0, len(PERDIDASopt), 5))
            ax.set_xticklabels(PERDIDASopt.index[::5], rotation=45, ha='right')

            plt.ylabel('Precip. depth (mm)')
            #plt.grid(True, linestyle='--', alpha=0.6)

            # Calcular sumas totales
            sums = PERDIDASopt[["P","Ia","F","Pe"]].sum()
            # Crear una tabla con las sumas
            plt.table(cellText=[sums.values.round(2)],
                     colLabels=sums.index,
                     cellLoc='center',
                     loc='bottom',
                     bbox=[0.18, -0.4, 0.6, 0.2])

            #plt.show()

            # Guardar imagen temporal
            #temp_dir = tempfile.gettempdir()
            temp_dir = workdir
            imagen_path = os.path.join(temp_dir, 'CNlossOpt.png')

            plt.savefig(imagen_path, dpi=150, bbox_inches='tight')
            plt.close()

            # Mostrar en QGIS #SOLO FUNIONARA EN QGIS
            dialog = QDialog()
            dialog.setWindowTitle('Result CN loss method')
            layout = QVBoxLayout()
            label = QLabel()
            label.setPixmap(QPixmap(imagen_path))
            layout.addWidget(label)
            dialog.setLayout(layout)
            dialog.exec_()








        
        

###OK ESTO PARA AÑADIR A LA CAPA CUENCA LAS COSAS:####VER EN QGIS

# #ummm vamos a meter en la capa las cosas:
# layer.startEditing()
    
# if layer.dataProvider().fieldNameIndex("P") == -1:
#     layer.dataProvider().addAttributes([QgsField("P", QVariant.Double)])
# if layer.dataProvider().fieldNameIndex("Pe") == -1:
#     layer.dataProvider().addAttributes([QgsField("Pe", QVariant.Double)])
# if layer.dataProvider().fieldNameIndex("Ia") == -1:
#     layer.dataProvider().addAttributes([QgsField("Ia", QVariant.Double)])
# if layer.dataProvider().fieldNameIndex("F") == -1:
#     layer.dataProvider().addAttributes([QgsField("F", QVariant.Double)])
# if layer.dataProvider().fieldNameIndex("PeakSim") == -1:
#     layer.dataProvider().addAttributes([QgsField("PeakSim", QVariant.Double)])

# layer.updateFields()

# id_P= layer.dataProvider().fieldNameIndex("P")
# id_Pe= layer.dataProvider().fieldNameIndex("Pe")
# id_Ia= layer.dataProvider().fieldNameIndex("Ia")
# id_F= layer.dataProvider().fieldNameIndex("F")
# id_PeakSim= layer.dataProvider().fieldNameIndex("PeakSim")

# for feature in layer.getFeatures():
#     layer.changeAttributeValue(feature.id(), id_P, PERDIDAS.P.max())
#     layer.changeAttributeValue(feature.id(), id_Pe, PERDIDAS.Pe.max())
#     layer.changeAttributeValue(feature.id(), id_Ia, PERDIDAS.Ia.max())
#     layer.changeAttributeValue(feature.id(), id_F, PERDIDAS.F.max())
#     layer.changeAttributeValue(feature.id(), id_PeakSim, huConv.max())

# layer.commitChanges()




















    #PACOGOM ok para el cancel
    def cancel(self):
        self.dlg.destroy()



    #OK Y AQUI COLOCO EL RESTO DE LA EJECUCION
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            #self.first_start = False #PACOGOM lo comentan
            self.dlg = ModelUHDialog()
        
        #PACOGOM TODO ESTO ES CODIGO TMABIEN
        self.dlg.cb_invector.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        vlayer = self.dlg.cb_invector.currentLayer()
        #print (vlayer)
        #
        self.dlg.output.setStorageMode(self.dlg.output.SaveFile)
        self.dlg.output.setConfirmOverwrite(True)
        self.dlg.output.setFilter(self.tr("ESRI Shapefile (*.shp *.SHP)"))        
        #
        self.dlg.cb_lp.setLayer(vlayer)
        self.dlg.cb_area.setLayer(vlayer)
        self.dlg.cb_ID.setLayer(vlayer)#ID DE LAS SUBCUENCAS
        self.dlg.cb_max_height.setLayer(vlayer)
        self.dlg.cb_min_height.setLayer(vlayer)
        self.dlg.cb_cn.setLayer(vlayer)
        #
        self.dlg.cb_invector.layerChanged.connect(self.select_layer_fields)
        self.dlg.cb_lp.fieldChanged.connect(self.check_box_able)
        self.dlg.cb_area.fieldChanged.connect(self.check_box_able)
        self.dlg.cb_ID.fieldChanged.connect(self.check_box_able)
        self.dlg.cb_max_height.fieldChanged.connect(self.check_box_able)
        self.dlg.cb_min_height.fieldChanged.connect(self.check_box_able)
        self.dlg.cb_cn.fieldChanged.connect(self.check_box_able)
        
        #PACOGOM y ver para ccon
        self.dlg.input_P.setFilter(self.tr("CSV files (*.csv *.CSV)"))
        self.dlg.input_Q.setFilter(self.tr("CSV files (*.csv *.CSV)"))

        # show the dialog
        self.dlg.show()
        

        #PACOGOM Y LLAMADA A process o cancel
        self.dlg.pushButtoncancel.clicked.connect(self.cancel)
        self.dlg.pushButtonok.clicked.connect(self.process)
        

        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
