# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ModelUH
                                 A QGIS plugin
 PACOGOM METE DESCRIPCION
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-05-21
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Water and Environment Institute (INUAMA). University of Murcia
        email                : fjgomariz@um.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Model_UH_dialog import ModelUHDialog
import os.path

from qgis.core import *
import random

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import geopandas as gpd
import networkx as nx

import base64

from qgis.PyQt.QtWidgets import QTableWidgetItem

class ModelUH:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ModelUH_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

        self.actions = []
        self.menu = self.tr(u'&Model UH')

        self.first_start = None
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ModelUH', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Model_UH/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Model UH for events'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

        self.help_action = QAction(
            QIcon("testplug:icon.png"),
            self.tr("Test Plugin Model UH"),
            self.iface.mainWindow()
        )

        self.iface.pluginHelpMenu().addAction(self.help_action)
        self.help_action.triggered.connect(self.show_help)
        
    @staticmethod
    def show_help():
        """ Open the online help. """
        QDesktopServices.openUrl(QUrl('https://www.um.es'))

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Model UH'),
                action)
            self.iface.removeToolBarIcon(action)

    def select_layer_fields(self, vlayer):
        self.dlg.cb_ID.setLayer(vlayer)
        self.dlg.cb_cn.setLayer(vlayer)
        self.dlg.cb_area.setLayer(vlayer)
        self.dlg.cb_lp.setLayer(vlayer)
        self.dlg.cb_max_height.setLayer(vlayer)
        self.dlg.cb_min_height.setLayer(vlayer)

        field = self.dlg.cb_lp.setLayer(vlayer)
        
    def check_box_able(self):
 
        colCN = self.dlg.cb_cn.currentField()
        
        if colCN == "":
            self.dlg.rb_dry.setEnabled(False)
            self.dlg.rb_normal.setEnabled(False)
            self.dlg.rb_wet.setEnabled(False)
        else:
            self.dlg.rb_dry.setEnabled(True)
            self.dlg.rb_normal.setEnabled(True)
            self.dlg.rb_wet.setEnabled(True)
 
    def sql_funtion(self):
        vlayer = self.dlg.cb_invector.currentLayer()
        field = self.dlg.cb_lp.currentText()
        
    
    def llenar_tabla(self, dataframe,table,colid):

        tabla = table
        encabezados = dataframe.columns.tolist()
        nombres_filas = dataframe.index.tolist()
        
        tabla.setColumnCount(len(encabezados) + 1)
        tabla.setRowCount(len(dataframe))
        
        nombre_indice = colid
        if dataframe.index.name:
            nombre_indice = dataframe.index.name
            
        tabla.setHorizontalHeaderLabels([nombre_indice] + encabezados)

        for fila_idx, fila in enumerate(dataframe.values.tolist()):
            item_indice = QTableWidgetItem(str(nombres_filas[fila_idx]))
            tabla.setItem(fila_idx, 0, item_indice)
            
            for columna_idx, valor in enumerate(fila):
                item = QTableWidgetItem(str(valor))
                tabla.setItem(fila_idx, columna_idx + 1, item)

        tabla.resizeColumnsToContents()
        tabla.horizontalHeader().setStretchLastSection(True)
        tabla.setStyleSheet("QHeaderView::section { background-color: #4CAF50; color: white; }")
        
        tabla.resizeRowsToContents()
        tabla.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)

    def load_image(self, path, web_view):
               
        with open(path, "rb") as img_file:
            img_data = img_file.read()
            img_base64 = base64.b64encode(img_data).decode("utf-8")
        
        html_content = f"""
        <html>
        <body style="margin:0; display:flex; justify-content:center; align-items:center; height:100vh;">
            <img src="data:image/png;base64,{img_base64}" style="max-width:100%; max-height:100%;">
        </body>
        </html>
        """
        
        web_view.setHtml(html_content)
    
    def process(self,vlayer):

        try:
            import pip
        except:
            execfile(os.path.join(self.plugin_dir, get_pip.py))
            import pip
            # just in case the included version is old
            pip.main(['install','--upgrade','pip'])

        try:
            import math
        except:
            pip.main(['install', 'math'])

        try:
            import numpy
        except:
            pip.main(['install', 'numpy'])
            
        try:
            import tempfile
        except:
            pip.main(['install', 'tempfile'])
        try:
            import pandas
        except:
            pip.main(['install', 'pandas'])

        try:
            import sys
        except:
            pip.main(['install', 'sys'])  
            
        try:
            import os
        except:
            pip.main(['install', 'os'])    
        try:
            import matplotlib.pyplot
        except:
            pip.main(['install', 'matplotlib.pyplot'])   

        try:
#            from scipy.optimize import minimize
            import scipy.optimize
        except:
            pip.main(['install','--upgrade' ,'scipy.optimize']) 
       

        #Functions
        def funncMod(p=[1,2,3,4,5], nc=58):
            S = 25400/nc - 254
            Ia = 0.2*S
            PeTot = ((np.sum(p) - 0.2*S)**2)/(np.sum(p) + 0.8*S)
            Fa = np.sum(p)- (Ia+PeTot) 
            P_ac = np.cumsum(p)
            Ia_ac, Pe_ac, F_ac = [np.nan]*len(p),  [np.nan]*len(p), [np.nan]*len(p)
            for t in range(len(p)):
                Ia_ac[t] = P_ac[t] if P_ac[t]<Ia  else Ia   
                Pe_ac[t]=( (P_ac[t]-Ia_ac[t])**2) / (P_ac[t] + S -Ia_ac[t])
                F_ac[t]=P_ac[t]-(Pe_ac[t]+Ia_ac[t])
            Pe = [Pe_ac[0]];Pe.extend(np.diff(Pe_ac))
            F = [F_ac[0]]; F.extend(np.diff(F_ac))
            Ia = [Ia_ac[0]]; Ia.extend(np.diff(Ia_ac))

            return(pd.DataFrame({"P":p, "Ia":Ia, "F":F, "Pe":Pe}))

        def funHUmod(area:float,tc:float, duracion:int, dt:int=30, prop:bool=False):
            tp = duracion/2 + 0.35*tc
            qp = 0.208 * area /tp
            tb = 2.67* tp
            q = []
            pasos = round(tb*60)
            for i in range(pasos):
                t=(i-1)/60
                if t<=tp: q.append(t*qp/tp)
                if t>tp:  q.append(qp - (t-tp)*qp/(tb-tp))
            q = [qq*60 for qq in q]
            qcum = []
            for i in range(0,len(q),dt): 
                qcum.append(sum(q[i:i+dt]))
            if prop is False:
                return(qcum)
            else: 
                qprop = [q/sum(qcum) for q in qcum]                             
            return(qprop)

        def funHUconv(p, hu, area, intervalo):
            area = area * 1000000
            intervalo = intervalo * 3600
            h = [0] * (len(p)+len(hu)-1)
            for t in range(len(hu)): 
                conv = hu[t] * p
                h[t:(t+len(p))] = h[t:(t+len(p))] + conv
   
            return([hh*area/(1000*intervalo) for hh in h])
            
        def funmuskingummod(I, dt:float ,K:float ,X:float, o0:float=0):
           
            I = np.asarray(I)
            n = len(I)
            O = np.zeros(n)

            O[0] = o0
                
            #if X < 0 or X > 0.5:
                #raise ValueError("The parameter X must be between 0 and 0.5 in Muskingum")
            #    QMessageBox.critical(self.iface.pluginMenu(), "Muskingum parameter problem", 'The parameter X must be between 0 and 0.5')
                
            #    process.kill()
            #if dt > 2 * K * X:
                #raise ValueError("dt must be ≤ 2*K*X for to avoid negative coefficients in Muskingum.")
            #    QMessageBox.critical(self.iface.pluginMenu(), f"dt must be ≤ {2*K*X} for to avoid negative coefficients.")
            #    process.kill()

            D = 2 * K * (1 - X) + dt
            C0 = (dt - 2 * K * X) / D
            C1 = (dt + 2 * K * X) / D
            C2 = (2 * K * (1 - X) - dt) / D

            #if C0 < 0 or C1 < 0 or C2 < 0:
                #raise ValueError("Negative coefficients in Muskingum. Adjust K, X or dt.")
            #    QMessageBox.critical(self.iface.pluginMenu(), "Negative coefficients. Adjust K, X or dt.")
            #    process.kill()
            
            for t in range(1, n):
                O[t] = C0 * I[t] + C1 * I[t-1] + C2 * O[t-1]
            
            return O
            
        def funModel(p, area, duracion, nc, tc):

            PERDIDAS = funncMod(p, nc)
   
            hu = funHUmod(area, tc, duracion)
            huProp = [h/sum(hu) for h in hu]
            Pe = np.array(PERDIDAS["Pe"])
            huConv = funHUconv(Pe, huProp, area, duracion)

            if(len(huConv) > len(Pe)):
                 huConv = huConv[0:len(Pe)]
        
            return huConv   
            
        def funnse(predictions, targets):
            return 1 - (np.sum((targets - predictions) ** 2) / np.sum((targets - np.mean(targets)) ** 2))
    
        def funrmse(predictions, targets):
            return np.sqrt(((predictions - targets) ** 2).mean())
    
        def funpbias(predictions, targets):
            return (np.sum(targets - predictions) / np.sum(predictions)) * 100

        def objectiveRMSE(params, p, area, duracion, qobs):
            #K, x = params
            nc, tc = params
            qsim = funModel(p, area, duracion, nc, tc)
            f0 = funrmse(np.array(qsim),np.array(qobs))
            return f0

        def objectiveNSE(params, p, area, duracion, qobs):
            #K, x = params
            nc, tc = params
            qsim = funModel(p, area, duracion, nc, tc)
            f0 = funnse(np.array(qsim),np.array(qobs))
            return - f0

        if self.dlg.output2.filePath() == '':
           QMessageBox.information(self.iface.pluginMenu(), "Output directory", 'There is not output directory')
        elif self.dlg.input_P.filePath() == '':
            QMessageBox.information(self.iface.pluginMenu(), "Input data", 'There is not input precipitation file')
        elif self.dlg.cb_ID.currentField() == '':
            QMessageBox.information(self.iface.pluginMenu(), "Required field parameters", 'There is not subbasins ID')
        elif self.dlg.cb_area.currentField() == '':
            QMessageBox.information(self.iface.pluginMenu(), "Required field parameters", 'There is not subbasins area')    
        elif self.dlg.cb_lp.currentField() == '':
            QMessageBox.information(self.iface.pluginMenu(), "Required field parameters", 'There is not subbasins length flowpath')                
        elif self.dlg.cb_min_height.currentField() == '':
            QMessageBox.information(self.iface.pluginMenu(), "Required field parameters", 'There is not subbasins min. height in lenth flowpath')        
        elif self.dlg.cb_max_height.currentField() == '':
            QMessageBox.information(self.iface.pluginMenu(), "Required field parameters", 'There is not subbasins max. height in lenth flowpath')             
        elif self.dlg.cb_cn.currentField() == '':
            QMessageBox.information(self.iface.pluginMenu(), "Required field parameters", 'There is not subbasins curve number (CN) values')

        else:
        
            import os
            
            duracion = self.dlg.lineEdit_interval.text()            
            duracion = float(duracion) / 60
            
            if not duracion:
                QMessageBox.critical(self.iface.pluginMenu(), "Time interval error", "The time interval field cannot be empty")
                return
            
            try:
                duracion = int(duracion)
            except ValueError:
                QMessageBox.critical(self.iface.pluginMenu(), "Time interval error", "Invalid time interval value")

            
            if self.dlg.output2.filePath() != '':
                workdir = self.dlg.output2.filePath()

            archivoprec = self.dlg.input_P.filePath()
            codidp = 0
 
            archivoqobs = self.dlg.input_Q.filePath()
            colqobs = 3
      
            precip = pd.read_csv(archivoprec)
            iddate = precip.iloc[:,codidp]

            if self.dlg.input_Q.filePath() != '':
                qobserved = pd.read_csv(archivoqobs)
                qobs = qobserved.iloc[:,colqobs].values
                iddate, qobs
            else:
                iddate

            
            layer = self.dlg.cb_invector.currentLayer()
            colCN = self.dlg.cb_cn.currentField()
            colsup = self.dlg.cb_area.currentField()
            colidbasin = self.dlg.cb_ID.currentField()
            collen = self.dlg.cb_lp.currentField()
            colcmax = self.dlg.cb_max_height.currentField()
            colcmin = self.dlg.cb_min_height.currentField()
            
            colrlen = self.dlg.cb_lc.currentField() 
            colrcmin = self.dlg.cb_minl.currentField() 
            colrcmax = self.dlg.cb_maxl.currentField() 
            colX = self.dlg.cb_X.currentField() 
            
            
            subbasins = pd.DataFrame([feat.attributes() for feat in layer.getFeatures()],columns=[field.name() for field in layer.fields()])

            G = nx.DiGraph()
            for _, row in subbasins.iterrows():
                G.add_node(row[colidbasin])
                if row['Downstream'] not in (None, -1):
                    G.add_edge(row[colidbasin], row['Downstream'])

            subbasins_order = list(nx.topological_sort(G))
            subbasin_last = subbasins_order[-1]
            nx.draw(G, with_labels=True, node_color='lightblue', node_size=800)
            plt.title("Network")

            temp_dir = workdir
            imagen_path = os.path.join(temp_dir, 'NETWORK.png')
            plt.savefig(imagen_path, dpi=150, bbox_inches='tight')
            plt.close()

            resultados = {}
            resultsres = pd.DataFrame()
            resultsfull = {}           
          
            for subbasin_id in subbasins_order:

                afluentes = list(G.predecessors(subbasin_id))
                entradas = [resultados[afluente] for afluente in afluentes]
                entradas2 = [sum(x) for x in zip(*entradas)]

                p = precip.loc[:,subbasin_id].values

                subbasin_values = subbasins[subbasins[colidbasin] == subbasin_id]

                CN = subbasin_values.iloc[0][colCN]

                if self.dlg.rb_normal.isChecked():
                    CNt = CN
                else:
                    if self.dlg.rb_dry.isChecked():
                        CNt = (4.2 * CN) / (10 - (0.058 * CN))
                    elif self.dlg.rb_wet.isChecked():
                        CNt = (23 * CN) / (10 + (0.13 * CN))

                desnivel = subbasin_values.iloc[0][colcmax] - subbasin_values.iloc[0][colcmin]
                pendiente = desnivel/(1000*subbasin_values.iloc[0][collen])
                tc2 = 0.3 * (subbasin_values.iloc[0][collen] / pendiente**0.25)**0.76
                
                area = subbasin_values.iloc[0][colsup]


                PERDIDASopt = funncMod(p=p, nc=CNt)

                plt.figure(figsize=(10, 6))
                ax = PERDIDASopt[["Ia","F","Pe"]].plot(kind='bar', stacked=True, color=['red', 'green', 'blue'])

                plt.title(f"Results of CN loss. Basin: {subbasin_id}; NC: {CNt}")
                plt.xlabel('Time')

                ax.set_xticks(range(0, len(PERDIDASopt), 5))
                ax.set_xticklabels(PERDIDASopt.index[::5], rotation=45, ha='right')

                plt.ylabel('Precip. depth (mm)')

                sums = PERDIDASopt[["P","Ia","F","Pe"]].sum()
                plt.table(cellText=[sums.values.round(2)],
                            colLabels=sums.index,
                            cellLoc='center',
                            loc='bottom',
                            bbox=[0.18, -0.4, 0.6, 0.2])

                temp_dir = workdir
                imagen_path = os.path.join(temp_dir, f"{subbasin_id}_cnloss.png")

                plt.savefig(imagen_path, dpi=150, bbox_inches='tight')
                plt.close()

                hu = funHUmod(area, tc2, duracion)
                huProp = [h/sum(hu) for h in hu]
                Pe = np.array(PERDIDASopt["Pe"])
                huConv = funHUconv(Pe, huProp, area, duracion)

                if(len(huConv) > len(Pe)):
                    huConv = huConv[0:len(Pe)]

                if(len(np.array(entradas2)) > 0):

                    if self.dlg.ch_routing.isChecked():
                        X = subbasin_values.iloc[0][colX]
                        #and K
                        diffR = subbasin_values.iloc[0][colrcmax] - subbasin_values.iloc[0][colrcmin]
                        slopeR = diffR/(1000*subbasin_values.iloc[0][colrlen])
                        tcR = 0.3 * (subbasin_values.iloc[0][colrlen] / slopeR**0.25)**0.76
                        K = 0.6 * tcR
                        outputMusk = funmuskingummod(np.array(entradas2), duracion ,K ,X)
                        totalUH = np.array(huConv) + np.array(outputMusk)
                    else:
                        totalUH = np.array(huConv) + np.array(entradas2)
                else:
                    totalUH = huConv
                            
                plt.figure(figsize=(10, 6))
                plt.plot(iddate,totalUH,color='blue',label='Simulated outflow',linestyle='-')
                plt.title(f"Result hidrogram. Basin: {subbasin_id}")
                plt.xlabel('Time')
                plt.ylabel('Flow (m3/s)')
                plt.grid(True, linestyle='--', alpha=0.6)
                plt.legend()
                temp_dir = workdir
                imagen_path = os.path.join(temp_dir, f"{subbasin_id}_hidrogram.png")

                plt.savefig(imagen_path, dpi=150, bbox_inches='tight')
                plt.close()

                resultados[subbasin_id] = totalUH

                resultsfull[f"{subbasin_id}_P"] = np.array(PERDIDASopt["P"])
                resultsfull[f"{subbasin_id}_Ia"] = np.array(PERDIDASopt["Ia"])
                resultsfull[f"{subbasin_id}_F"] = np.array(PERDIDASopt["F"])
                resultsfull[f"{subbasin_id}_Pe"] = np.array(PERDIDASopt["Pe"])
                resultsfull[f"{subbasin_id}_Qsim"] = totalUH
                
                sums['PeakSim'] = max(totalUH)
                sums2 = pd.DataFrame(data=sums)
                sums2.columns = [subbasin_id]
                resultsres = pd.concat([resultsres, sums2], axis=1)

            resultsfull2 = pd.DataFrame(resultsfull)
            csv_path = os.path.join(temp_dir, 'RESULTS_details.csv')
            resultsfull2.to_csv(csv_path)

            if (archivoqobs is not None):
                resultsres.at['PeakObs', subbasin_last] = max(qobs)
                
                qsim = resultsfull2[f"{subbasin_last}_Qsim"]

                resultsres.at['rmse', subbasin_last] = funrmse(np.array(qsim),np.array(qobs))
                resultsres.at['pbias', subbasin_last] = funpbias(np.array(qsim),np.array(qobs))
                resultsres.at['nse', subbasin_last] = funnse(np.array(qsim),np.array(qobs))

                plt.plot(iddate,qsim,color='blue',label='Simulated outflow',linestyle='-')
                plt.plot(iddate,qobs,color='black', label='Observed outflow', linestyle='-',marker='o',markersize=3,alpha=0.7)
                plt.title(f"Result hidrogram. Basin: {subbasin_last}")
                plt.xlabel('Time')
                plt.ylabel('Flow (m3/s)')
                plt.grid(True, linestyle='--', alpha=0.6)
                plt.legend()
                
                temp_dir = workdir
                imagen_path = os.path.join(temp_dir, f"{subbasin_last}_hidrogram.png")
                plt.savefig(imagen_path, dpi=150, bbox_inches='tight')
                plt.close()
            
            resultsres2 = pd.DataFrame.transpose(resultsres)
            csv_path = os.path.join(temp_dir, 'RESULTS_resum.csv')
            resultsres2.to_csv(csv_path)
 

            ####OPTIMIZACION
            
            
            
            
            
            
            
            
            


            self.llenar_tabla(resultsres2.round(decimals=4),self.dlg.table_results,"Basin")
            self.llenar_tabla(resultsfull2.round(decimals=4),self.dlg.table_results_2,"id")
            
            imagen_path = os.path.join(workdir, f"{subbasin_last}_hidrogram.png")

            self.load_image(imagen_path, self.dlg.figView)
            
            self.dlg.tabWidget.setCurrentIndex(1)




            
            

            #QMessageBox.information(self.iface.pluginMenu(), "Veamos los valores", f"Valor subbasin_id: {subbasin_id}, ;;;;;;; resultados: {resultsres}, tipo: {type(resultsres)}")
                
                
                
    def cancel(self):
        self.dlg.destroy()

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.dlg = ModelUHDialog()
        
        self.dlg.cb_invector.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        vlayer = self.dlg.cb_invector.currentLayer()

        self.dlg.cb_lp.setLayer(vlayer)
        self.dlg.cb_area.setLayer(vlayer)
        self.dlg.cb_ID.setLayer(vlayer)
        self.dlg.cb_max_height.setLayer(vlayer)
        self.dlg.cb_min_height.setLayer(vlayer)
        self.dlg.cb_cn.setLayer(vlayer)
        #
        self.dlg.cb_invector.layerChanged.connect(self.select_layer_fields)
        self.dlg.cb_lp.fieldChanged.connect(self.check_box_able)
        self.dlg.cb_area.fieldChanged.connect(self.check_box_able)
        self.dlg.cb_ID.fieldChanged.connect(self.check_box_able)
        self.dlg.cb_max_height.fieldChanged.connect(self.check_box_able)
        self.dlg.cb_min_height.fieldChanged.connect(self.check_box_able)
        self.dlg.cb_cn.fieldChanged.connect(self.check_box_able)
        #
        self.dlg.input_P.setFilter(self.tr("CSV files (*.csv *.CSV)"))
        self.dlg.input_Q.setFilter(self.tr("CSV files (*.csv *.CSV)"))

        self.dlg.show()
        
        self.dlg.pushButtoncancel.clicked.connect(self.cancel)
        self.dlg.pushButtonok.clicked.connect(self.process)
        

        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
